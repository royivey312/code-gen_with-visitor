item sets
bison - translates prod => LALR(1)
byacc-j -J

input for both (.y file)
2 production
3 any other code

1 'definitions'
%{ code early in output %}
inclues and var ub the actions

%tokenb list of tokens

%start start non-term

bison 0d 0y .yfile=y.tab.c
-y => y.tab.h - token names and numbers

byacc.j -J .ufile => Parser.java
                     ParserVal.java

actions: want the parser to produce a representation: tree
[theory iS "Attributes" and "attributed grammers"]

every symbol can have attributes = values attached to it

attributes pressed down to children[inherited]

attributes passed up to parents [synthesized] via yacc and bison

a yacc action is a code block at the end of a production

they can be in the middle of a production, DON'T try this

It can make new S/R conflicts
an action looks like { code }
                       C^Java

each symbol on RHS has an attribute value
in action $#, count from loeft most symbol on RHS of prod

zB_
program: Ident declaration code End
          $1      $2        $3   $4


the final action should produce an attribute value for the LHS

$$ is the "name" for the LHS


The types I want for $ things the default type is int

I can: 
1 declare the possible types
2 declare which type each symbol takes

we add to part 1

%union{type1 ident1; type2 ident2; ..... }

( this vecome the type of the values on the value stack)

zb %union{ int i; tree t;}


to declare actual type for each non-terminal

%type<union ident> blank sep list of non-terms

zb %type <t> code decl_sect

I also need to do this for tokens for any such token, in .y file

%token <union ident> ____

zb_
%token <i> Ident IntConst
%token Program End If ....

to give an attribute value to tokens, I need to go back to the .l file

when you include y.tab.h, there is a declaration of the union and a var yylval of that union type

in the lex action for the token and an assignment to yylval.

zb in .l file 
{D}+ {yylvalye.i = atoi(yytext);
      return IntConst
